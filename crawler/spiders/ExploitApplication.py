from scrapy.selector import HtmlXPathSelector
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor
from urlparse import urlparse
# from scrapy.contrib.spiders import CrawlSpider, Rule
# from scrapy.spider import Spider
from scrapy.spider import BaseSpider
from crawler.items import LinkItem
from scrapy.http import Request
from scrapy import signals
from scrapy.xlib.pydispatch import dispatcher
import scrapy
from scrapy.http import FormRequest
from scrapy import log
from loginform import fill_login_form
import json
#import injection
import urllib, urllib2
from BeautifulSoup import BeautifulSoup,SoupStrainer

class NewSpider(BaseSpider):
    name =  'login_stage3'
    allowed_domains=[]#["app5.com"]
    start_urls = []#['https://app5.com/www/index.php']
    item_urls = []
    all_urls = []
    login_user = 'admin'
    login_pass = 'admin'
    json_objects = []
    #-------------------------------------
    GET_attacksurls=[]
    GET_validExpUrls = []
    GET_visitedExpUrls = []

    POST_potExploits = []
    POST_validExploits = []
    POST_visitedExploits = []

    validExploits = []
    visitedExploits = []
    saveExploitBeforeExploit = {}
    handle_httpstatus_list = [500, 404, 301]
    pot_exploits = []
    patterns_in_exploits = []
    '''
      Input/Output Files into Stage3: Exploit Validation
    '''
    pot_exploits_file = 'json/Stage2_json_objects.json' #out stage 2
    patterns_file = 'json/patternUpd.json' # patre
    valid_exploits_file = 'json/Stage3_valid_exploits.json'
    #----------------------------
    
    #def parse(self, response):
    #    args, url, method = fill_login_form(response.url, response.body, self.login_user, self.login_pass)
     #   return FormRequest(url, method=method, formdata=args, dont_filter=True,callback=self.after_login)
      #  return FormRequest.from_response(
       #      response,            
        #     formdata={'user': 'admin', 'password': 'admin'},
              # method="POST",
         #      dont_filter=True,
          #   callback=self.after_login
         #)
   #      return Request(url=self.start_urls[0],
    #                  callback=self.parse_page)
        #return [scrapy.FormRequest(self.start_urls[0], 
         #   formdata={'Username': 'admin', 'Password': 'admin'},
          #   callback=self.after_login)]
    
    def parse(self, response):
      # args, url, method = fill_login_form(response.url, response.body, self.login_user, self.login_pass)
       #return FormRequest(url, method=method, formdata=args, dont_filter=True,callback=self.after_login)
      args, url, method, name , number = fill_login_form(response.url, response.body, self.login_user, self.login_pass)
      if name:
        yield FormRequest.from_response(response, method=method, formdata=args, formname=name,  dont_filter=True,callback=self.after_login)
      else:
        yield FormRequest.from_response(response, method=method, formdata=args, formnumber=number,  dont_filter=True,callback=self.after_login)

    def parse1(self, response):
      return FormRequest.from_response(response,  formdata={'user': 'admin', 'password': 'admin'},  dont_filter=True, callback=self.payload_generation("Stage2.json"))

    def __init__(self,filename = None):
        temp = []
        if filename:
            with open(filename, 'r') as f:
                temp = f.readlines()

        self.start_urls.append(temp[0].strip())
        self.allowed_domains.append(temp[1].strip())

        self.remove_duplicates_in_json_file(self.pot_exploits_file)

        self.pot_exploits = self.load_pot_exploits(self.pot_exploits_file)
        self.patterns_in_exploits = self.load_pattens_in_exploits(self.patterns_file)

        self.process_GET_POST_attckVectors(self.pot_exploits)

        dispatcher.connect(self.spider_closed, signals.spider_closed)               

    def remove_duplicates_in_json_file(self, jsonFile):

      fobj = open(jsonFile, 'r')
      json_data = json.loads(fobj.read())

      new_list=[]
      for item in json_data["exploits"]:

        if len(new_list)==0:
          new_list.append(item)
        else:
          match = False
          for new_item in new_list:
            match = self.isExploitEqual(item, new_item)
            if (match):
              break
          if (not match):
            new_list.append(item)

      jsonObj = {}
      jsonObj["exploits"] = new_list
      fobj = open(jsonFile, 'w')
      jsonString = json.dumps(jsonObj, indent=4, sort_keys=True)
      fobj.write(jsonString)
      fobj.close()

    # Potential Exploits. 
    def load_pot_exploits(self, pot_exploits_file):
      f = open(pot_exploits_file, 'r').read();
      pot_exploits_data = json.loads(f)
      pot_exploits = pot_exploits_data["exploits"]
      return pot_exploits

    # Patterns in Exploits.
    def load_pattens_in_exploits(self, patterns_in_exploits_file):
      f = open(patterns_in_exploits_file, 'r').read();
      patterns_in_exploits_data = json.loads(f)
      patterns_in_exploits = patterns_in_exploits_data["pattern"]
      return patterns_in_exploits

    def isExploitEqual (self, exploit1, exploit2):
      url1 = str(exploit1["url"]).strip()
      url2 = str(exploit2["url"]).strip()

      if not (url2 == url1):
        return False

      if not (exploit1["method"] == exploit2["method"]):
        return False

      params1 = exploit1["params"]
      params2 = exploit2["params"]

      if not (len(params1) == len(params2)):
        return False

      hashP1 = 0
      for p1 in params1:
        hashP1 = hashP1 + hash(str(p1["key"].strip()) + "<~>" + str(p1["value"].strip()))

      hashP2 = 0
      for p2 in params2:
        hashP2 = hashP2 + hash(str(p2["key"].strip()) + "<~>" + str(p2["value"].strip()))

      if hashP1==hashP2:
        return True
      return False

    def process_GET_POST_attckVectors(self, potExploits):

      for exp in potExploits:
        if exp["method"] == "GET":

          atkUrl = str(exp["url"]).strip();
          params = exp["params"]
          paramCount = len(params)
          if (paramCount>0):
            atkUrl = atkUrl + "?"
          for param in params:
            paramCount = paramCount - 1
            atkUrl = atkUrl + str(param["key"]) + '=' + str(param["value"])
            if(paramCount > 0):
              atkUrl = atkUrl + "&"
          atkUrl = atkUrl.strip()

          self.GET_attacksurls.insert(0, atkUrl)
        else :
          self.POST_potExploits.insert(0, exp)

    def is_GET_AtkUrlAttacked(self, atkUrl):
      for url in self.GET_visitedExpUrls:
        if atkUrl.strip() == url:
          return True
      return False

    def is_POST_ExploitAttacked(self, postAtkExp):
      for post_exp in self.POST_visitedExploits:
        if(self.isExploitEqual(post_exp, postAtkExp)):
          return True
      return False

    def after_login(self, response):

        if "The username/password combination you have entered is invalid" in response.body:
            self.log("Login failed", level=log.ERROR)
            return        
        # continue scraping with authenticated session...
        elif "logout" in response.body:
            print "This is response url " +  response.url
            self.log("Login succeed!", level=log.DEBUG)
            return Request(url=response.url,
                           callback=self.parse_page)
        else:
            print "Error1111"
            return Request(url=response.url,
                           callback=self.parse_page)

    def parse_page(self, response):
        print ">>> Response parse page res-call>>> " + response.url
        if (response.status == 500) or (response.status == 404):
          print ">>> Response parse page res-call-body >>> " + response.body

        for pattern in self.patterns_in_exploits:
          if str(pattern).strip() in response.body:
            print str(pattern)
            print response.body
            if self.saveExploitBeforeExploit["method"]=="GET":
              self.GET_validExpUrls.insert(0, self.saveExploitBeforeExploit["GET_URL"])
            elif self.saveExploitBeforeExploit["method"]=="POST":
              self.POST_validExploits.insert(0, self.saveExploitBeforeExploit["POST_EXP"])
            break

        if (not (len(self.GET_visitedExpUrls)==len(self.GET_attacksurls))) and (len(self.GET_attacksurls) > 0):
          print ">>> parse_page -- entered GET check:"
          GetNotAttacked = False
          notAttackedUrl = ""
          for get_atkUrl in self.GET_attacksurls:
            if not self.is_GET_AtkUrlAttacked(get_atkUrl.strip()):
              notAttackedUrl = get_atkUrl.strip()
              self.GET_visitedExpUrls.insert(0, notAttackedUrl)
              GetNotAttacked = True
              break
          self.saveExploitBeforeExploit = {}
          if (GetNotAttacked) :
            self.saveExploitBeforeExploit["method"]="GET"
            self.saveExploitBeforeExploit["GET_URL"] = notAttackedUrl
            yield Request(url=notAttackedUrl, callback=self.parse_page)
        else :
          PostNotAttacked = False
          notAttackedExploit = {}
          for exploitElement in self.POST_potExploits:
            print 'pot-exp'
            print exploitElement
            if(not self.is_POST_ExploitAttacked(exploitElement)):
              self.POST_visitedExploits.insert(0, exploitElement)
              notAttackedExploit = exploitElement
              PostNotAttacked = True
              break
          self.saveExploitBeforeExploit = {}
          if (PostNotAttacked):
            self.saveExploitBeforeExploit["method"] = "POST"
            self.saveExploitBeforeExploit["POST_EXP"] = notAttackedExploit
            params = notAttackedExploit["params"]
            payload = {}
            for p in params:
              payload[p["key"]] = p["value"]
            yield Request(url=str(notAttackedExploit["url"]).strip(), callback=self.parse_page, method="POST", body=urllib.urlencode(payload))
        
    def spider_closed(self, spider):
      self.validExploits = []
      if (len(self.POST_validExploits) > 0):
        self.validExploits.extend(self.POST_validExploits)
      GET_dict_Array = self.convertGetUrlToDictArray(self.GET_validExpUrls)
      if len(GET_dict_Array) > 0:
        self.validExploits.extend(GET_dict_Array)
        ''' Generate Valid Exploits Json '''
      self.generated_valid_exploit_json()
      
    def collect_item(self, item):
        return item

    def convertGetUrlToDictArray(self, atkUrlArray):
      get_json_exp = []
      for atkUrl in atkUrlArray:
        url = atkUrl
        q_idx = url.find("?")
        if not (q_idx== -1):
          dict_url = url[:q_idx]
          dict_params = []
          pm_url = url[q_idx+1:]
          for p in pm_url.split("&"):
            k_v = p.split("=")
            param = {}
            param["key"] = str(k_v[0]).strip()
            param["value"] = str(k_v[1]).strip()
            dict_params.insert(0, param)
          exp = {}
          exp["method"] = "GET"
          exp["url"] = dict_url
          exp["params"] = dict_params
          get_json_exp.insert(0, exp)
      return get_json_exp

    def generated_valid_exploit_json(self) :
      jsonObj = {}
      if len(self.validExploits) > 0 :
        jsonObj["exploits"] = self.validExploits
      else :
        jsonObj["exploits"] = []
      f = open(self.valid_exploits_file, 'w')
      jsonString = json.dumps(jsonObj, indent=4, sort_keys=True)
      f.write(jsonString)
      f.close()